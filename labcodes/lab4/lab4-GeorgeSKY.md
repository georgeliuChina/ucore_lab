# Lab4 Report
# 刘相  P14206021

## 练习1

设计过程：

创建一个进程的过程就是给对应的结构成员赋值，ucore中默认fork出的进程状态为PROC_UNINIT表示未被初始化，pid先取-1等待稍后被get_pid分配，栈、被重调度、父进程、地址空间、中断帧都为未分配的状态，赋为0即可。

回答问题：
context 用于保存程序运行的上下文，其中的成员变量是8个寄存器的值，用于进程切换时保存与回复现场。

tf这个trapframe结构表示进程的中断帧结构，本实验中在创建init_main函数的内核线程时初始化了它的中断帧，记录了内核的代码段与数据段等参数，指定了线程运行的入口地址。

## 练习2

设计过程：
根据代码中注释的提示，首先为新进程分配一个描述结构PCB，然后完成进一步的初始化过程。包括父进程id设置为当前进程，设置栈结构和复制地址空间，然后将进程的执行状态用copy_thread拷贝到新的栈与地址空间中。设计新进程的pid，将其PCB加入到hash链表和proc_list中，调用wakeup_proc将进程唤醒准备执行。

回答问题:
是的，ucore可以保证每个进程的pid唯一。在proc.c中定义了MAX_PROCESS与MAX_PID宏，而MAX_PID是MAX_PROCESS的2倍，在get_pid函数中，每次遍历整个进程链表确保每个现有进程的pid与选中的last_pid不同。另外将MAX_PID设为MAX_PROCESS的2倍，且将next_safe和last_pid作为静态变量记录上次pid的分配状态都可以加速这个唯一性寻找的过程。

## 练习3

1.2个内核线程，idleproc与initproc，前者用于一些基本的初始化工作使程序进入调度状态（使用cpu_idle）。后者用于执行init_main函数来做进一步的初始化工作。

2.这2条语句用于关闭中断和恢复中断，在lab4中，ucore在向终端输出字符、分配物理页帧、释放页、进程调度时都会先关闭中断，操作完成后再开启中断。

## 与参考答案的对比

由于大部分的实现遵照代码中的注释，本实验的编码量也并不很大，所以与参考答案基本没有什么不同。只有在do_fork中将进程加入到链表中时，参考答案中使用了local_intr_save和local_intr_store两个函数关闭中断与开启中断。

## 实验中的知识点

实验中对进程调度时的PCB结构描述的比较清楚，从单进程运行到多进程调度的实现过程也较为明晰，主要体现在idleproc和initproc的创建。

## 原理课中的知识点

原理课中叙述的进程的各种状态以及进程的控制功能在实验中没有实现，应该是在下一次实验中进行。
